<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Path_tracker</title>

<style>
body{
    font-family:Arial;
    background:#0f1117;
    color:white;
    text-align:center;
}
button{
    padding:14px 30px;
    font-size:18px;
    margin:10px;
    border:none;
    border-radius:8px;
    background:#00c853;
    color:white;
    cursor:pointer;
}
canvas{
    background:white;
    border:3px solid #00c853;
    margin-top:20px;
}
.stat{
    font-size:22px;
    margin:8px;
}
</style>
</head>

<body>

<h1>üõ∞Ô∏è Path_tracker LIVE</h1>

<button onclick="connectBLE()">üì° Connect BLE</button>

<div class="stat">Steps: <span id="steps">0</span></div>
<div class="stat">Distance: <span id="distance">0</span> m</div>
<div class="stat">X: <span id="posX">0</span></div>
<div class="stat">Y: <span id="posY">0</span></div>

<canvas id="canvas" width="700" height="500"></canvas>

<script>
let device;
let pathData=[];
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const scale=60;

async function connectBLE(){
try{

device = await navigator.bluetooth.requestDevice({
  filters:[{name:'PathTracker'}],
  optionalServices:['19b10000-e8f2-537e-4f6c-d104768a1214']
});

const server = await device.gatt.connect();
const service = await server.getPrimaryService('19b10000-e8f2-537e-4f6c-d104768a1214');

const posChar = await service.getCharacteristic('19b10001-e8f2-537e-4f6c-d104768a1214');
const stepChar = await service.getCharacteristic('19b10002-e8f2-537e-4f6c-d104768a1214');
const distChar = await service.getCharacteristic('19b10003-e8f2-537e-4f6c-d104768a1214');

await posChar.startNotifications();
posChar.addEventListener('characteristicvaluechanged', event=>{
    const value=new TextDecoder().decode(event.target.value);
    const parts=value.split(",");
    if(parts.length==2){
        const x=parseFloat(parts[0]);
        const y=parseFloat(parts[1]);

        pathData.push({x,y});

        document.getElementById("posX").textContent=x.toFixed(2);
        document.getElementById("posY").textContent=y.toFixed(2);

        drawPath();
    }
});

await stepChar.startNotifications();
stepChar.addEventListener('characteristicvaluechanged', e=>{
    const v=e.target.value.getInt32(0,true);
    document.getElementById("steps").textContent=v;
});

await distChar.startNotifications();
distChar.addEventListener('characteristicvaluechanged', e=>{
    const v=e.target.value.getFloat32(0,true);
    document.getElementById("distance").textContent=v.toFixed(2);
});

alert("‚úÖ Connected to PathTracker");

}catch(err){
alert("‚ùå Connection failed: "+err);
}
}

function drawPath(){
ctx.clearRect(0,0,canvas.width,canvas.height);

const cx=canvas.width/2;
const cy=canvas.height/2;

// grid
ctx.strokeStyle="#eee";
for(let i=-20;i<20;i++){
ctx.beginPath();
ctx.moveTo(0,cy+i*scale);
ctx.lineTo(canvas.width,cy+i*scale);
ctx.stroke();

ctx.beginPath();
ctx.moveTo(cx+i*scale,0);
ctx.lineTo(cx+i*scale,canvas.height);
ctx.stroke();
}

if(pathData.length<2) return;

ctx.strokeStyle="blue";
ctx.lineWidth=4;
ctx.beginPath();

ctx.moveTo(cx+pathData[0].x*scale, cy-pathData[0].y*scale);

for(let p of pathData){
ctx.lineTo(cx+p.x*scale, cy-p.y*scale);
}

ctx.stroke();

// start point
ctx.fillStyle="green";
ctx.beginPath();
ctx.arc(cx+pathData[0].x*scale, cy-pathData[0].y*scale,6,0,6.28);
ctx.fill();

// end point
let last=pathData[pathData.length-1];
ctx.fillStyle="red";
ctx.beginPath();
ctx.arc(cx+last.x*scale, cy-last.y*scale,6,0,6.28);
ctx.fill();
}
</script>

</body>
</html>
